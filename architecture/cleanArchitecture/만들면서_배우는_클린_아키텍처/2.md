# 의존성 역전하기

1장에서 나온 불만들의 대안에는 무엇이 있을까?

해당 장에서는 SRP(Single Responsibility Principle)과 DIP(Dependency Inversion Principle)를 활용하여 앞선 불만을 해결하는 것을 다루고 있다.

### 단일 책임 원칙
단일 책임 원칙에 대해 다음과 같이 알고 있는가?  

    흔히 하나의 컴포넌트는 오로지 한 가지 일만 해야 하고, 그것을 올바르게 수행해야 한다.
이는 오해이며 SRP에 대해 직역 한 것일 뿐이다.

단일 책임 원칙 즉 SRP는 다음과 같은 정의를 가진다.

    컴포넌트를 변경하는 이유는 오직 하나뿐이여야 한다.
'책임'은 '하나의 일만을 행하는 것'이 아닌, '하나의 변경할 이유를 가진다'로 해석할 수 있다.

'변경할 이유'가 하나라면 어차피 하나의 일만을 수행할 수 있다.

그럼 왜 이전 불만을 해결하는데에 단일 책임 원칙이 나온 것일까?  

하나의 서비스가 많은 영속성 계층에 의존관계를 형성하고, 많은 유스케이스를 담당하고 있다면 해당 서비스를 변경하는 이유는 한가지일까?

변경 이유가 한가지라는 것은 하나의 책임만을 담당하는 것이며, 이는 많은 영속성 계층에 의존할 필요는 없을 것이다.

즉, 이전에 서비스가 많은 영속성 계층을 의존하여 문제가 발생하는 것은 단일 책임 원칙을 지키지 못해 발생하는 것일 수 있다.

### 의존성 역전 원칙
우리는 하위 계층을 향해 의존성을 가지고 있다.

도메인 계층이 영속성 계층의 변경에 영향을 받게 된다면 비즈니스 로직을 안전하게 지킬 수 있을까?

아무래도 어려울 것으로 생각한다. 그럼 우리가 도메인 계층을 수정하는 이유는 비즈니스 로직의 변경 혹은 확장이 아닌 하위 계층 변경의 영향으로 변경하는 상황이 발생 할 수 있다.

이때, 하위 계층의 변경의 영향력과 멀어질 수 있는 방법으로 의존성 역전 원칙을 사용할 수 있다.

쉽게 영속성 계층이 도메인 계층을 의존하도록 하는 것이다.

이전 계층 구조를 봐보자.
```plaintext
+------------+
|   Service  | <- 도메인 계층
+------------+
       |
       |
       v
+------------+
| Repository | <- 영속성 계층
+------------+
```
위 의존관계를 보면 Service가 Repository에 의존관계를 형성하고 있는 것을 확인할 수 있다.

이를 의존성 역전 원칙을 통해 다음과 같이 변경할 수 있다.
```plaintext
+------------------------------------+
|   Service -> Repository Interface  | <- 도메인 계층
+------------------------------------+
                        ^
                        |
                        |
                 +------------+
                 | Repository | <- 영속성 계층
                 +------------+
```
Service에서 작업 목록 즉 영속성 계층에 있는 구현체의 interface를 제공하며,
이를 참조하면 영속성 계층에서는 해당 Interface를 구현하는 구현체를 만들게 된다.

이렇게 될경우 의존 역행 영속성 계층에서 도메인 계층에 의존관계를 가지게 된다.

그리하여 도메인 계층의 비즈니스 규칙들은 영속성 계층의 변경 영향력으로 부터 안전해질 수 있게 된다.

## 클린 아키텍처
로버트 C. 마틴은 이와 같은 규칙들을 통해 '클린 아키텍처'를 정의한다.  

클린 아키텍처는 외부에서 내부로 즉 core로 향하는 의존성 규칙 즉 종속성 규칙을 가장 중시하는 아키텍처이다.

비즈니스 규칙들을 외부로부터 독립적으로 만들어 비즈니스 규칙들의 테스트, 유지보수, 확장성등을 용이 하게 만들어준다.

core에서는 외부 시스템이 어떤 것들이 사용되었는지 알 필요가 없어지니 완전히 독립적인 구조를 가질 수 있다.

## 헥사고날 아키텍처
알리스테어 콕번이 정의한 아키텍처로, 클린 아키텍처보다 먼저 정의된 아키텍처이다.

해당 아키텍처는 외부 시스템과의 연결을 Ports, Adapter를 통해 통신하게 되는데, 이는 외부 시스템으로부터 애플리케이션 내부 구현을 보호하기 위함이며 이는 내부 시스템의 독립성을 보장하게 된다.

위와 같은 아키텍처들의 적용을 통해 도메인 코드가 외부에 의존하지 않게 되면서 여러 문제들로부터 도메인 코드와의 결합을 제거하여 도메인 코드를 변경할 이유를 줄이는데 강점이 존재한다.

